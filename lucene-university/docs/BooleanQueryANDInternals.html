<!DOCTYPE html>

<html>
<head>
  <title>Conjunctive Boolean query (AND) internals</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="AnalyzerBasics.html">
                  AnalyzerBasics.java
                </a>
              
                
                <a class="source" href="BooleanQueryANDInternals.html">
                  BooleanQueryANDInternals.java
                </a>
              
                
                <a class="source" href="BooleanQueryIntro.html">
                  BooleanQueryIntro.java
                </a>
              
                
                <a class="source" href="BottomUpIndexReader.html">
                  BottomUpIndexReader.java
                </a>
              
                
                <a class="source" href="DirectoryFileContents.html">
                  DirectoryFileContents.java
                </a>
              
                
                <a class="source" href="FunctionQuerySearchExample.html">
                  FunctionQuerySearchExample.java
                </a>
              
                
                <a class="source" href="KnnSearchExample.html">
                  KnnSearchExample.java
                </a>
              
                
                <a class="source" href="PointTreeRangeQuery.html">
                  PointTreeRangeQuery.java
                </a>
              
                
                <a class="source" href="SearchWithTermsEnum.html">
                  SearchWithTermsEnum.java
                </a>
              
                
                <a class="source" href="SimpleSearch.html">
                  SimpleSearch.java
                </a>
              
                
                <a class="source" href="VisualizePointTree.html">
                  VisualizePointTree.java
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              <h1 id="conjunctive-boolean-query-and-internals">Conjunctive Boolean query (AND) internals</h1>
<p>This example partly builds on top of the concepts introduced in <code>BooleanQueryIntro</code>, so I suggest you go check
that example first.</p>
<p>If you happen to have arrived here through a web search, please <strong>DO NOT ACTUALLY USE THIS CODE</strong>. Lucene already
has a BooleanQuery class. See the neighboring <code>BooleanQueryIntro</code> example for some guidance on using it.</p>
<p>This example digs into some of the implementation details for Boolean queries, specifically conjunctive (<code>AND</code>)
queries. Since Lucene’s real Boolean queries are quite sophisticated, most of this example will involve building
our own version of a Boolean query that behaves like a binary “AND” operator. That is, it has exactly two clauses,
which are both required (and participate in scoring). Along the way, we’ll learn some things about how Lucene
queries in general are implemented, and how Boolean queries implement “leap-frogging”.</p>
<p>Before we get into the code, here is an overview of the chain of classes we need to implement for our own query:</p>
<ol>
<li><code>Query</code>: A query represents the instruction for <em>what</em> we want to match/score, without getting into the details
     of <em>how</em> we’re going to do so.</li>
<li><code>Weight</code>: Returned by the <code>createWeight</code> method on the query. The JavaDoc for <code>Weight</code> says, “The purpose of
     Weight is to ensure searching does not modify a Query, so that a Query instance can be reused.” While
     the <code>Query</code> is independent of any index state, the <code>Weight</code> is constructed based on the current
     <code>IndexSearcher</code>, and properties of the search action (e.g. whether scoring is needed).</li>
<li><code>Scorer</code>: For each index segment, the <code>Weight</code> creates a <code>Scorer</code>. The <code>Scorer</code> may be used once to step through
     matching documents in the segment (via its embedded <code>DocIdSetIterator</code> – explained next), and returns
     the score (at this query’s level) for the document.</li>
<li><code>DocIdSetIterator</code>: A <code>DocIdSetIterator</code> (often abbreviated to DISI) steps through matching document IDs for the
     given segment in increasing order. Many DISIs support an efficient <code>advance(int n)</code> method that returns
     the matching doc ID greater than or equal to <code>n</code>.</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">package</span> example.basic;

<span class="hljs-keyword">import</span> org.apache.lucene.document.Field;
<span class="hljs-keyword">import</span> org.apache.lucene.document.TextField;
<span class="hljs-keyword">import</span> org.apache.lucene.index.DirectoryReader;
<span class="hljs-keyword">import</span> org.apache.lucene.index.IndexReader;
<span class="hljs-keyword">import</span> org.apache.lucene.index.IndexWriter;
<span class="hljs-keyword">import</span> org.apache.lucene.index.IndexWriterConfig;
<span class="hljs-keyword">import</span> org.apache.lucene.index.LeafReaderContext;
<span class="hljs-keyword">import</span> org.apache.lucene.index.Term;
<span class="hljs-keyword">import</span> org.apache.lucene.search.BooleanClause;
<span class="hljs-keyword">import</span> org.apache.lucene.search.DocIdSetIterator;
<span class="hljs-keyword">import</span> org.apache.lucene.search.Explanation;
<span class="hljs-keyword">import</span> org.apache.lucene.search.IndexSearcher;
<span class="hljs-keyword">import</span> org.apache.lucene.search.Query;
<span class="hljs-keyword">import</span> org.apache.lucene.search.QueryVisitor;
<span class="hljs-keyword">import</span> org.apache.lucene.search.ScoreDoc;
<span class="hljs-keyword">import</span> org.apache.lucene.search.ScoreMode;
<span class="hljs-keyword">import</span> org.apache.lucene.search.Scorer;
<span class="hljs-keyword">import</span> org.apache.lucene.search.TermQuery;
<span class="hljs-keyword">import</span> org.apache.lucene.search.TopDocs;
<span class="hljs-keyword">import</span> org.apache.lucene.search.Weight;
<span class="hljs-keyword">import</span> org.apache.lucene.search.similarities.BasicStats;
<span class="hljs-keyword">import</span> org.apache.lucene.search.similarities.SimilarityBase;
<span class="hljs-keyword">import</span> org.apache.lucene.store.Directory;
<span class="hljs-keyword">import</span> org.apache.lucene.store.FSDirectory;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.nio.file.Files;
<span class="hljs-keyword">import</span> java.nio.file.Path;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BooleanQueryANDInternals</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <h2 id="document-construction">Document construction</h2>
<p>We’ll reuse the documents from <code>BooleanQueryIntro</code>. In brief, the documents contain the words for their
prime factors less than 10.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">createDocumentText</span><span class="hljs-params">(<span class="hljs-type">int</span> numDocs)</span> {
        List&lt;String&gt; docs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        docs.add(<span class="hljs-string">&quot;zero&quot;</span>); <span class="hljs-comment">/* First doc will just have &quot;zero&quot;, since the first doc ID is 0 */</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numDocs; i++) {
            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
            sb.append(<span class="hljs-string">&quot;one&quot;</span>);
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                sb.append(<span class="hljs-string">&quot; two&quot;</span>);
            }
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
                sb.append(<span class="hljs-string">&quot; three&quot;</span>);
            }
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
                sb.append(<span class="hljs-string">&quot; five&quot;</span>);
            }
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>) {
                sb.append(<span class="hljs-string">&quot; seven&quot;</span>);
            }
            docs.add(sb.toString());
        }
        <span class="hljs-keyword">return</span> docs;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">&#x00a7;</a>
              </div>
              <h2 id="query-class">Query class</h2>
<p>Let’s start with our custom query class. Since we want to represent the specific <code>a AND b</code> case, we will
explicitly take <code>a</code> and <code>b</code> as “left” and “right” operands.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryAndQuery</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Query</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Query left;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Query right;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryAndQuery</span><span class="hljs-params">(Query left, Query right)</span> {
            <span class="hljs-built_in">this</span>.left = Objects.requireNonNull(left);
            <span class="hljs-built_in">this</span>.right = Objects.requireNonNull(right);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">&#x00a7;</a>
              </div>
              <p>A query should implement a friendly <code>toString</code> method that provides a human-readable representation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(String field)</span> {
            <span class="hljs-keyword">return</span> left.toString(field) + <span class="hljs-string">&quot; AND &quot;</span> + right.toString(field);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">&#x00a7;</a>
              </div>
              <p>To allow operations on complex query hierarchies, queries are expected to take a <code>QueryVisitor</code> and pass
it down the tree. The “leaf” queries at the end of a query hierarchy should call <code>visitor.visitLeaf(this)</code>.
Functionally, this implementation is identical to what <code>BooleanQuery</code> will do with a pair of <code>MUST</code> clauses.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(QueryVisitor visitor)</span> {
            <span class="hljs-type">QueryVisitor</span> <span class="hljs-variable">childVisitor</span> <span class="hljs-operator">=</span> visitor.getSubVisitor(BooleanClause.Occur.MUST, <span class="hljs-built_in">this</span>);
            left.visit(childVisitor);
            right.visit(childVisitor);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">&#x00a7;</a>
              </div>
              <p>Since a <code>Query</code> may be used as a hash key (e.g. if the results of the query are cached), they are expected
to correctly implement <code>equals</code> and <code>hashCode</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-type">BinaryAndQuery</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (BinaryAndQuery) o;
            <span class="hljs-keyword">return</span> Objects.equals(left, that.left) &amp;&amp; Objects.equals(right, that.right);
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> Objects.hash(left, right);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-7">&#x00a7;</a>
              </div>
              <p>Finally, when it comes time to search with our query, we create the <code>Weight</code> instance. Note that
we need to call <code>createWeight</code> on each of our nested queries, too. Note that while we could call
<code>createWeight</code> on the <code>left</code> and <code>right</code> queries directly, it is more correct to delegate to the <code>searcher</code>,
which may have one of the nested queries in its cache. (See the <code>isCacheable</code> method in <code>BinaryAndWeight</code>,
below.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Weight <span class="hljs-title function_">createWeight</span><span class="hljs-params">(IndexSearcher searcher, ScoreMode scoreMode, <span class="hljs-type">float</span> boost)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryAndWeight</span>(<span class="hljs-built_in">this</span>, searcher.createWeight(left, scoreMode, boost), searcher.createWeight(right, scoreMode, boost));
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-8">&#x00a7;</a>
              </div>
              <h2 id="weight-class">Weight class</h2>
<p>For our purposes, the role of the <code>Weight</code> implementation is to hold the <code>Weight</code> instances for the operands,
create the <code>Scorer</code> for each segment, and implement the <code>explain</code> method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryAndWeight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Weight</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Weight leftWeight;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Weight rightWeight;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryAndWeight</span><span class="hljs-params">(Query query, Weight leftWeight, Weight rightWeight)</span> {
            <span class="hljs-built_in">super</span>(query);
            <span class="hljs-built_in">this</span>.leftWeight = leftWeight;
            <span class="hljs-built_in">this</span>.rightWeight = rightWeight;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-9">&#x00a7;</a>
              </div>
              <p>Every <code>Weight</code> is expected to implement the <code>explain</code> method to show how a given document’s score was
derived (or to explain why a non-matching document did not match).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Explanation <span class="hljs-title function_">explain</span><span class="hljs-params">(LeafReaderContext context, <span class="hljs-type">int</span> doc)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-type">Explanation</span> <span class="hljs-variable">leftExplain</span> <span class="hljs-operator">=</span> leftWeight.explain(context, doc);
            <span class="hljs-type">Explanation</span> <span class="hljs-variable">rightExplain</span> <span class="hljs-operator">=</span> rightWeight.explain(context, doc);
            <span class="hljs-keyword">if</span> (!leftExplain.isMatch()) {
                <span class="hljs-keyword">return</span> Explanation.noMatch(<span class="hljs-string">&quot;no match on required clause (&quot;</span> + leftWeight.getQuery().toString() + <span class="hljs-string">&quot;)&quot;</span>, leftExplain);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!rightExplain.isMatch()) {
                <span class="hljs-keyword">return</span> Explanation.noMatch(<span class="hljs-string">&quot;no match on required clause (&quot;</span> + rightWeight.getQuery().toString() + <span class="hljs-string">&quot;)&quot;</span>, rightExplain);
            }
            <span class="hljs-type">Scorer</span> <span class="hljs-variable">scorer</span> <span class="hljs-operator">=</span> scorer(context);
            <span class="hljs-type">int</span> <span class="hljs-variable">advanced</span> <span class="hljs-operator">=</span> scorer.iterator().advance(doc);
            <span class="hljs-type">assert</span> <span class="hljs-variable">advanced</span> <span class="hljs-operator">=</span>= doc;
            <span class="hljs-keyword">return</span> Explanation.match(scorer.score(), <span class="hljs-string">&quot;sum of:&quot;</span>, leftExplain, rightExplain);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-10">&#x00a7;</a>
              </div>
              <p>We return our custom <code>Scorer</code> implementation for a given index segment, after creating the scorers for
each of our operands.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Scorer <span class="hljs-title function_">scorer</span><span class="hljs-params">(LeafReaderContext context)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryAndScorer</span>(<span class="hljs-built_in">this</span>, leftWeight.scorer(context), rightWeight.scorer(context));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-11">&#x00a7;</a>
              </div>
              <p>The <code>IndexSearcher</code> holds a <code>QueryCache</code> instance that may store the matching doc IDs for a given query.
Not all queries are readily cacheable, though, so the <code>IndexSearcher</code> asks the weight if it is cacheable
or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCacheable</span><span class="hljs-params">(LeafReaderContext ctx)</span> {
            <span class="hljs-keyword">return</span> leftWeight.isCacheable(ctx) &amp;&amp; rightWeight.isCacheable(ctx);
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-12">&#x00a7;</a>
              </div>
              <h3 id="scorer-class">Scorer class</h3>
<p>Next, we need to implement the <code>Scorer</code> class. Most of the interesting logic lives in the <code>Scorer</code>‘s associated
<code>DocIdSetIterator</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryAndScorer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Scorer</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Scorer leftScorer;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Scorer rightScorer;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DocIdSetIterator docIdSetIterator;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryAndScorer</span><span class="hljs-params">(Weight weight, Scorer leftScorer, Scorer rightScorer)</span> {
            <span class="hljs-built_in">super</span>(weight);
            <span class="hljs-built_in">this</span>.leftScorer = leftScorer;
            <span class="hljs-built_in">this</span>.rightScorer = rightScorer;
            <span class="hljs-built_in">this</span>.docIdSetIterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryAndDocIdSetIterator</span>(leftScorer.iterator(), rightScorer.iterator());
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-13">&#x00a7;</a>
              </div>
              <p>If this scorer is pointing at a doc ID, then both the left and right scorers must be pointing at the
same doc ID (since it’s the current match for the left AND right).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">docID</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">assert</span> leftScorer.docID() == rightScorer.docID();
            <span class="hljs-keyword">return</span> docIdSetIterator.docID();
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> DocIdSetIterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> docIdSetIterator;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-14">&#x00a7;</a>
              </div>
              <p>This <code>getMaxScore</code> can be used to skip entire blocks of uncompetitive documents, by providing an upper bound
on the possible score of a match. In this case, we ask each of our subscorers what their maximum scores
are <code>upTo</code> some future target and sum them together. But the max from <code>left</code> and the max from <code>right</code> might
not come from the same document, so there may not actually be a document with this score. That’s okay,
though – the skipping is a best-effort optimization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getMaxScore</span><span class="hljs-params">(<span class="hljs-type">int</span> upTo)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">return</span> leftScorer.getMaxScore(upTo) + rightScorer.getMaxScore(upTo);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-15">&#x00a7;</a>
              </div>
              <p>Consistent with BooleanQuery (using MUST clauses), we sum up the scores of our individual clauses.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">score</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">assert</span> leftScorer.docID() == rightScorer.docID();
            <span class="hljs-keyword">return</span> leftScorer.score() + rightScorer.score();
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-16">&#x00a7;</a>
              </div>
              <h2 id="the-docidsetiterator-class">The DocIdSetIterator class</h2>
<p>This class is really the whole reason for this example (though the journey was hopefully informative too).
The DocIdSetIterator (DISI) classes are fundamental to Lucene’s matching logic.</p>
<p>Conjunctions of required clauses (like our AND query) step through all documents where all of their underlying
DISIs point to the same thing. We achieve this with the (generally) fast <code>advance</code> method, asking a DISI
that’s behind to skip to the first value greater than or equal to the DISI that’s in the lead. If they point
to the same thing, then we have a match and return it. Otherwise, the old lead is now behind and it can leap
over the new lead, like a game of leapfrog.</p>
<p>Note that our <code>advance</code> and <code>nextDoc</code> methods guarantee that they only return when <code>leftIterator</code> and
<code>rightIterator</code> point to the same value (though that value may be <code>NO_MORE_DOCS</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryAndDocIdSetIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DocIdSetIterator</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DocIdSetIterator leftIterator;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DocIdSetIterator rightIterator;

        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryAndDocIdSetIterator</span><span class="hljs-params">(DocIdSetIterator leftIterator, DocIdSetIterator rightIterator)</span> {
            <span class="hljs-built_in">this</span>.leftIterator = leftIterator;
            <span class="hljs-built_in">this</span>.rightIterator = rightIterator;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-17">&#x00a7;</a>
              </div>
              <p>We can (and do) check the invariant that the left and right iterators are pointing to the same doc,
and return the left doc ID.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">docID</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">assert</span> leftIterator.docID() == rightIterator.docID();
            <span class="hljs-keyword">return</span> leftIterator.docID();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-18">&#x00a7;</a>
              </div>
              <p>For <code>nextDoc</code>, we arbitrarily step to the next document with <code>leftIterator</code>, then jump over to our
leapfrogging logic in <code>doNext</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">return</span> doNext(leftIterator.nextDoc());
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-19">&#x00a7;</a>
              </div>
              <p>As with <code>nextDoc</code>, we can <code>advance</code> the <code>leftIterator</code> and leapfrog in <code>doNext</code> until the iterators
converge.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">advance</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">return</span> doNext(leftIterator.advance(target));
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-20">&#x00a7;</a>
              </div>
              <p>Here it is, the exciting part of the example and one of the most important concepts in Lucene.
The left and right iterators jump over each other, with the lagging iterator advancing to the
first doc ID greater than or equal to the leading iterator. Several of the built-in query types (including
TermQuery) have efficient <code>advance</code> methods that can return in logarithmic time.</p>
<p>This <code>while</code> loop is guaranteed to terminate, because eventually both iterators will point to <code>NO_MORE_DOCS</code>,
and passing <code>NO_MORE_DOCS</code> to an <code>advance</code> call is expected to return <code>NO_MORE_DOCS</code>. (The comparators work
because <code>NO_MORE_DOCS</code> is equal to <code>Integer.MAX_VALUE</code>.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doNext</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> <span class="hljs-keyword">throws</span> IOException {
            <span class="hljs-keyword">while</span> (leftIterator.docID() != rightIterator.docID()) {
                <span class="hljs-keyword">if</span> (rightIterator.docID() &lt; leftIterator.docID()) {
                    rightIterator.advance(leftIterator.docID());
                } <span class="hljs-keyword">else</span> {
                    leftIterator.advance(rightIterator.docID());
                }
            }
            <span class="hljs-keyword">return</span> leftIterator.docID();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-21">&#x00a7;</a>
              </div>
              <p>The <code>cost()</code> of a DISI is a measure of how expensive it would be to step through it fully, generally
corresponding to an upper bound on the number of docs the DISI matches. We don’t know how many documents
are in the intersection of <code>left</code> and <code>right</code> without stepping through them, but we know that the
intersection of <code>left</code> and <code>right</code> is definitely no bigger than whichever is smaller. (Picture the Venn
diagram of “A AND B”.)</p>
<p>One use of <code>cost()</code> is to lead with the cheapest (sparsest) iterator. Since our <code>advance</code> method always
steps with <code>left</code> first and our “AND” operator is commutative, we could have assigned <code>leftIterator</code>
to the lower-cost iterator to get a speed-up. (That’s what Lucene’s <code>ConjunctionDISI</code> class does.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">cost</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> Math.min(leftIterator.cost(), rightIterator.cost());
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-22">&#x00a7;</a>
              </div>
              <p>We can reuse the custom similarity from <code>BooleanQueryIntro</code> to give our example term queries scores of <code>1</code> on a
match, rather than worrying about BM25 scores.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountMatchingClauseSimilarity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimilarityBase</span> {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> <span class="hljs-title function_">score</span><span class="hljs-params">(BasicStats stats, <span class="hljs-type">double</span> freq, <span class="hljs-type">double</span> docLen)</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Every match has a score of 1&quot;</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-23">&#x00a7;</a>
              </div>
              <p>While we didn’t look at it in <code>BooleanQueryIntro</code>, a custom similarity can also explain its scoring
methodology. In our case, we can pass along the explanation from the <code>toString</code> method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">explain</span><span class="hljs-params">(List&lt;Explanation&gt; subExpls, BasicStats stats, <span class="hljs-type">double</span> freq, <span class="hljs-type">double</span> docLen)</span> {
            subExpls.add(Explanation.match(<span class="hljs-number">1</span>, <span class="hljs-built_in">this</span>.toString()));
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-24">&#x00a7;</a>
              </div>
              <h2 id="tying-it-all-together">Tying it all together</h2>
<p>Let’s put our custom query type to work.</p>
<p>After indexing documents 0-999, we create a <code>twoAndFive</code> query, similar to what we did in <code>BooleanQueryIntro</code>,
but this time it’s using the logic implemented above.</p>
<p>When the <code>IndexSearcher</code> (or technically the <code>DefaultBulkScorer</code>) first calls <code>nextDoc</code> on our
<code>DocIdSetIterator</code>, the left iterator (“two) will step to its first match – document 2. Then the right (“five”)
iterator steps to its first match greater than or equal to 2 – document 5. Then the left iterator advances to
document 6. Then the right iterator advances to document 10. Finally, the left iterator advances to document 10
too, and we return it. (It’s the first hit in the returned <code>TopDocs</code>.)</p>
<p>The logic for the next (and every other) matching document is similar:</p>
<pre><code>left=<span class="hljs-number">12</span>
right=<span class="hljs-number">15</span>
left=<span class="hljs-number">16</span>
right=<span class="hljs-number">20</span> &lt;--
left=<span class="hljs-number">20</span> &lt;-- HIT
</code></pre>
<p>After returning the top 10 hits, we can take a look at the <code>explain</code> output to see the output from our
custom <code>Weight</code> and custom <code>Similarity</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">Path</span> <span class="hljs-variable">tmpDir</span> <span class="hljs-operator">=</span> Files.createTempDirectory(BooleanQueryIntro.class.getSimpleName());
        <span class="hljs-keyword">try</span> (<span class="hljs-type">Directory</span> <span class="hljs-variable">directory</span> <span class="hljs-operator">=</span> FSDirectory.open(tmpDir);
             <span class="hljs-type">IndexWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexWriter</span>(directory, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexWriterConfig</span>())) {
            <span class="hljs-keyword">for</span> (String doc : createDocumentText(<span class="hljs-number">1000</span>)) {
                writer.addDocument(List.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>(<span class="hljs-string">&quot;text&quot;</span>, doc, Field.Store.NO)));
            }

            <span class="hljs-keyword">try</span> (<span class="hljs-type">IndexReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> DirectoryReader.open(writer)) {
                <span class="hljs-type">IndexSearcher</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexSearcher</span>(reader);
                searcher.setSimilarity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountMatchingClauseSimilarity</span>());

                <span class="hljs-type">BinaryAndQuery</span> <span class="hljs-variable">twoAndFive</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryAndQuery</span>(
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TermQuery</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Term</span>(<span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>)),
                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TermQuery</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Term</span>(<span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>))
                );
                System.out.println(twoAndFive);
                <span class="hljs-type">TopDocs</span> <span class="hljs-variable">topDocs</span> <span class="hljs-operator">=</span> searcher.search(twoAndFive, <span class="hljs-number">10</span>);
                <span class="hljs-keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) {
                    System.out.println(scoreDoc.doc + <span class="hljs-string">&quot;  &quot;</span> + scoreDoc.score);
                }


                System.out.println(searcher.explain(twoAndFive, <span class="hljs-number">20</span>));
                <span class="hljs-comment">/*
                2.0 = sum of:
                  1.0 = weight(text:two in 20) [CountMatchingClauseSimilarity], result of:
                    1.0 = score(CountMatchingClauseSimilarity, freq=1.0), computed from:
                      1 = Every match has a score of 1
                  1.0 = weight(text:five in 20) [CountMatchingClauseSimilarity], result of:
                    1.0 = score(CountMatchingClauseSimilarity, freq=1.0), computed from:
                      1 = Every match has a score of 1
                */</span>

                System.out.println(searcher.explain(twoAndFive, <span class="hljs-number">22</span>));
                <span class="hljs-comment">/*
                0.0 = no match on required clause (text:five)
                  0.0 = no matching term
                */</span>
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">for</span> (String indexFile : FSDirectory.listAll(tmpDir)) {
                Files.deleteIfExists(tmpDir.resolve(indexFile));
            }
            Files.deleteIfExists(tmpDir);
        }
    }


}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
